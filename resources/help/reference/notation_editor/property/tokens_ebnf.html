<HTML><HEAD>    <LINK REL="stylesheet" HREF="../../../stylesheet.css"    >    <TITLE>CubeTwister - The Notation Editor - Parser Specification</TITLE>    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"></HEAD><BODY BGCOLOR="#FFFFFF"><H1>The Notation Editor - Specification of the Parser<A NAME="top"></A></H1><H2>A    few words about the lexical scanner (aka tokenizer):</H2><P>Whitespace is used    to delimit tokens. If the keywords &laquo;A&raquo;, &laquo;B&raquo; and &laquo;AB&raquo;    are defined, and the scanner encounters the character sequence &laquo;A&nbsp;B&raquo;,    then this is recognised as the token &laquo;A&raquo; followed by the token &laquo;B&raquo;.</P><P>The    scanner becomes greedy, if no whitespace is present between a sequence of characters.    It tries to assign as many characters to a token as possible. i.e. if the keywords    &laquo;A&raquo;, &laquo;B&raquo; and &laquo;AB&raquo; are defined, and the scanner    encounters the character sequence &laquo;ABB&raquo;, then this is recognised as    the token &laquo;AB&raquo; followed by the token &laquo;B&raquo;.</P><P>The scanner    also automatically recognises comments. Two types of comments are supported: C-style    line end comments starting with two slashes and ending with a new-line character,    and C++-style multi-line comments starting with slash and star and ending with    star and slash.</P><H2>Formal specification of the grammar:</H2><P>The following    productions written using EBNF ISO/IEC 1477 show the formal specification of the    grammar used to build the parser.</P><P>The grammar shown here is LALR(1). That    is, all productions can be determined by a <B>L</B>ook <B>A</B>head <B>L</B>eft    <B>R</B>ecursive algorithm, which uses a look ahead of only one <B>(1)</B> token.</P><P><tt>Script    = {Expression} ;<br> <br> Expression = StmtDelimiter | ({Prefix} , Statement ,    {Suffix}) ;<br> <br> StmtDelimiter = Keyword ;<br> Prefix = PrefixConjugator |    PrefixCommutator | PrefixInvertor | PrefixRepetitor | PrefixReflector ;<br> Statement    = Twist | Macro | (GroupingBegin | CngrPrefix | CmtrPrefix) Grouping | PermBegin    Permutation ;<br> Suffix = SuffixConjugator | SuffixCommutator | SuffixInvertor    | SuffixRepetitor | SuffixReflector ;<br> <br> PrefixConjugator = SuffixConjugator    = (CngrBegin , Expression , {Expression} , CngrEnd) | CngrTransformation ;<br>    PrefixCommutator = SuffixCommutator = (CmtrBegin , Expression , {Expression} ,    CmtrEnd) | CmtrTransformation ;<br> PrefixInvertor = SuffixInvertor = Keyword    ;<br> PrefixRepetitor = SuffixRepetitor = [RptrBegin] , Integer , [RptrEnd] ;<br>    PrefixReflector = SuffixReflector = Keyword ;<br> Twist = Identifier ;<br> Macro    = Identifier ;<br> Grouping = [(HeaderConjugator | HeaderCommutator) , Expression    , {Expression} , (GroupingEnd | CngrEnd | CmtrEnd) ;<br> HeaderConjugator = Expression    , {Expression} , CngrDelimiter ;<br> HeaderCommutator = Expression , {Expression}    , CmtrDelimiter ;<br> Permutation = [ (SidePerms| EdgePerms| CornerPerms) ], PermEnd    ;<br> Keyword = Character , {Character} ;<br> Character = ? any non-white space    character specified in the Unicode character set ? ;<br> <br> CmtrBegin = Keyword    ;<br> CmtrEnd = Keyword ;<br> CmtrDelimiter = Keyword ;<br> CngrBegin = Keyword    ;<br> CngrEnd = Keyword ;<br> CngrDelimiter = Keyword ;<br> RptrBegin = Keyword    ;<br> Integer = Digit , {Digit} ;<br> Digit = '0' | '1' | '2' | '3' | '4' | '5'    | '6' | '7' | '8' | '9' ;<br> RptrEnd = Keyword ;<br> Identifier = Keyword ;<br>    GroupingBegin = Keyword ;<br> GroupingEnd = Keyword ;<br> PermBegin = Keyword    ;<br> Sign = Identifier ;<br> SidePerms = [Sign] , SidePerm , {PrmDelimiter ,    [Sign] , SidePerm} ;<br> EdgePerms = [Sign] , EdgePerm , {PrmDelimiter , EdgePerm}    ;<br> CornerPerms = [Sign] , CornerPerm , {PrmDelimiter , CornerPerm} ;<br> PermEnd    = Keyword ;<br> <br> SidePerm = Face ;<br> PrmDelimiter = Keyword ;<br> EdgePerm    = Face Face ;<br> CornerPerm = Face Face Face ;<br> <br> Face = Identifier ;<br></tt></BODY></HTML>