/*
 * @(#)Node.java  3.1  2009-01-22
 *
 * Copyright (c) 2004-2009 Werner Randelshofer, Switzerland.
 * You may not use, copy or modify this file, except in compliance with the
 * accompanying license terms.
 */
package ch.randelshofer.rubik.parser;

import ch.randelshofer.gui.tree.TreeNodeImpl;
import ch.randelshofer.rubik.*;
import ch.randelshofer.util.EmptyEnumeration;
import ch.randelshofer.util.EnumerationIterator;
import ch.randelshofer.util.SingletonIterator;
import ch.randelshofer.util.ReverseListIterator;
import ch.randelshofer.util.ListOfLists;
import java.util.*;
import java.io.*;

/**
 * Abstract superclass for a Node in the parse tree generated by the Parser.
 *
 *
 * @author Werner Randelshofer
 * @version 3.1.1 2014-06-23 Fixes NPE in childIterator() when children is null.
 * <br>3.1 2009-01-22 Fixed reflect() method.
 * <br>3.0 2007-11-15 Upgraded to Java 1.4.
 * <br>2.1 2007-11-04 Implemented method transformOrientation.
 * <br>2.0 2005-01-31 Reworked.
 * <br>1.0 31 January 2005 Created.
 */
public abstract class Node extends TreeNodeImpl<Node> {
    private static final long serialVersionUID = 1L;

    /**
     * The start position of the first token in the source code, that is part of
     * this script.
     */
    protected int startpos;
    /**
     * The end position of the last token in the source code, that is part of
     * this script.
     */
    protected int endpos;
    /**
     * The Symbol that this node represents.
     */
    protected Symbol symbol;

    protected int layerCount;

    /**
     * Maps cube orientations to symbols.
     *
     * @see ch.randelshofer.rubik.RubiksCube#getOrientation()
     */
    private final static Move[][] orientationToMoveMap = {
        // R U F L D B
        {}, // 0
        {Move.CR}, {Move.CR2}, {Move.CL}, // 1 x-axis
        {Move.CU}, {Move.CU2}, {Move.CD}, // 2 y-axis
        {Move.CF}, {Move.CF2}, {Move.CB}, // 3 z-axis
        {Move.CR, Move.CU}, {Move.CR, Move.CU2}, {Move.CR, Move.CD},
        {Move.CR2, Move.CU}, {Move.CR2, Move.CD}, // 4 corner-axis from ru to ld
        {Move.CL, Move.CU}, {Move.CL, Move.CU2}, {Move.CL, Move.CD},
        {Move.CR, Move.CF}, {Move.CR, Move.CB}, // 5 corner-axis from lu to rd
        {Move.CR2, Move.CF}, {Move.CR2, Move.CB}, // 8 
        {Move.CL, Move.CF}, {Move.CL, Move.CB} // 9
    /*
     // F R D B L U
     {}, // 0
     {Move.CR}, {Move.CR2}, {Move.CL}, // 1
     {Move.CU}, {Move.CU2}, {Move.CD}, // 2
     {Move.CF}, {Move.CF2}, {Move.CB}, // 3
     {Move.CR, Move.CU}, {Move.CR, Move.CU2}, {Move.CR, Move.CD}, // 4
     {Move.CR2, Move.CU}, {Move.CR2, Move.CD}, // 5
     {Move.CL, Move.CU}, {Move.CL, Move.CU2}, {Move.CL, Move.CD}, // 6
     {Move.CR, Move.CF}, {Move.CR, Move.CB}, // 7
     {Move.CR2, Move.CF}, {Move.CR2, Move.CB}, // 8 
     {Move.CL, Move.CF}, {Move.CL, Move.CB} // 9
     */};

    /**
     * Creates a node which represents a symbol at the indicated position in the
     * source code.
     *
     * @param startpos The start position of the symbol.
     * @param endpos The end position of the symbol.
     */
    public Node(Symbol symbol, int layerCount, int startpos, int endpos) {
        this.symbol = symbol;
        this.startpos = startpos;
        this.endpos = endpos;
        this.layerCount = layerCount;
    }

    /**
     * Returns the start position of the symbol in the source code.
     */
    public int getStartPosition() {
        return startpos;
    }

    /**
     * Sets the start position of the symbol in the source code.
     */
    public void setStartPosition(int p) {
        startpos = p;
    }

    /**
     * Returns the end position of the symbol in the source code.
     */
    public int getEndPosition() {
        return endpos;
    }

    /**
     * Sets the end position of the symbol in the source code.
     */
    public void setEndPosition(int p) {
        endpos = p;
    }

    /**
     * Overwrite start and end positions of this node and the subtree starting
     * at this node.
     */
    public void overwritePositions(int sp, int ep) {
        startpos = sp;
        endpos = ep;
        if (children != null) {
            for (Node child : getChildren()) {
                child.overwritePositions(sp, ep);
            }
        }
    }

    /**
     * Applies the symbol represented by this node to the cube.
     *
     * @param cube A cube to be transformed by this symbol.
     * @param inverse If true, the transform will be done in inverse order.
     */
    public void applyTo(Cube cube, boolean inverse) {
        for (Iterator<Node> i = (inverse) ? reversedChildIterator() : childIterator(); i.hasNext();) {
            Node child = i.next();
            child.applyTo(cube, inverse);
        }
    }

    /**
     * Returns the ScriptParser symbol that represents this node.
     */
    public Symbol getSymbol() {
        return symbol;
    }

    /**
     * Dumps the subtree starting at this Node node. Use for debugging only.
     *
     * @param depth The number of spaces used for indenting.
     */
    public void dumpTree(int depth) {
        StringBuilder buf = new StringBuilder(depth);
        for (int i = 0; i < depth; i++) {
            buf.append('.');
        }
        buf.append(toString());
        System.out.println(buf.toString());
        depth++;
        for (Node n : getChildren()) {
            n.dumpTree(depth);
        }
    }

    /**
     * Returns a string representation of this node. Use for debugging only.
     */
    public String toString() {
        return getClass().getName() + " " + startpos + ".." + endpos;
    }

    /**
     * Returns a string representation of this node using the specified
     * notation.
     */
    public final String toString(Notation notation) throws IOException {
        return toString(notation, null);
    }

    /**
     * Returns a string representation of this node using the specified notation
     * and the specified local macros.
     */
    public final String toString(Notation notation, List<MacroNode> localMacros) throws IOException {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        HashMap<String, MacroNode> macroMap = new HashMap<String, MacroNode>();
        if (localMacros != null) {
            for (MacroNode mn : localMacros) {
                macroMap.put(mn.getIdentifier(), mn);
            }
        }

        writeTokens(pw, notation, macroMap);
        pw.close();
        return sw.toString();
    }

    /**
     * Transformes the subtree starting at this node by the given move. Does
     * nothing if the transformation can not be done.
     */
    public void transform(int axis, int layerMask, int angle) {
        for (Node elem : getChildren()) {
            elem.transform(axis, layerMask, angle);
        }
    }

    public void transform(MoveNode move, boolean inverse) {
        transform(move.getAxis(), move.getLayerMask(), (inverse) ? -move.getAngle() : move.getAngle());
    }

    /**
     * Transformes the subtree starting at this node by the given cube
     * orientation. Does nothing if the orientation can not be done.
     */
    public void transformOrientation(int cubeOrientation, boolean inverse) {
        // XXX - This method currently only works for 3x3 cubes. We need to pass a cube as a parameter
        if (cubeOrientation >= 1) {
            if (inverse) {
                add(new NOPNode(layerCount));
                if (orientationToMoveMap[cubeOrientation].length == 2) {
                    GroupingNode seq = new GroupingNode(layerCount);
                    seq.add(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][1].toInverse()));
                    seq.add(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][0].toInverse()));
                    add(seq);
                } else {
                    add(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][0].toInverse()));
                }
            } else {
                if (orientationToMoveMap[cubeOrientation].length == 2) {
                    GroupingNode seq = new GroupingNode(layerCount);
                    seq.add(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][0]));
                    seq.add(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][1]));
                    insert(seq, 0);
                } else {
                    insert(new MoveNode(layerCount, orientationToMoveMap[cubeOrientation][0]), 0);
                }
                insert(new NOPNode(layerCount), 1);
            }
        }
    }

    /**
     * Inverses the subtree starting at this node.
     */
    @SuppressWarnings("unchecked")
    public void inverse() {
        if (children != null) {
            Iterator<Node> enumer = reversedChildIterator();
            children = new Vector<Node>();
            while (enumer.hasNext()) {
                Node elem = enumer.next();
                elem.inverse();
                children.addElement(elem);
            }
        }
    }

    /**
     * Reflects the subtree starting at this node.
     */
    public void reflect() {
        if (children != null) {
            for (Node elem : getChildren()) {
                elem.reflect();
            }
        }
    }

    /**
     * Enumerates a resolved version of the subtree starting at this node. All
     * elements of the enumeration except of MoveNode's and PermutationNode's
     * may be safely ignored.
     * <p>
     * All nodes of the enumeration must be temporary, that is are explicitly
     * created for this enumeration.
     * <p>
     * The enumeration must not be empty!
     *
     * @param inverse Set to true if you wish to get an inverted enumeration.
     */
    public Iterator<Node> resolvedIterator(boolean inverse) {
        return new ResolvedIterator(this, inverse);
    }

    public Iterable<Node> resolvedIterable(final boolean inverse) {
        return new Iterable<Node>() {

            @Override
            public Iterator<Node> iterator() {
                return resolvedIterator(inverse);
            }

        };
    }

    @SuppressWarnings("unchecked")
    public Iterator<Node> childIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return children == null ? empty : children.iterator();
    }

    /**
     * Enumerates the direct children of this node in reverse order.
     */
    @SuppressWarnings("unchecked")
    public Iterator<Node> reversedChildIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return (children == null) ? empty : new ReverseListIterator<Node>(children);
    }

    /**
     * Gets the layer turn count of the subtree starting at this node.
     */
    public int getLayerTurnCount() {
        int count = 0;
        for (Node child : getChildren()) {
            count += child.getLayerTurnCount();
        }
        return count;
    }

    /**
     * Gets the block turn count of the subtree starting at this node.
     */
    public int getBlockTurnCount() {
        int count = 0;
        for (Node child : getChildren()) {
            count += child.getBlockTurnCount();
        }
        return count;
    }

    /**
     * Gets the face turn count of the subtree starting at this node.
     */
    public int getFaceTurnCount() {
        int count = 0;
        for (Node child : getChildren()) {
            count += child.getFaceTurnCount();
        }
        return count;
    }

    /**
     * Gets the quarter turn count of the subtree starting at this node.
     */
    public int getQuarterTurnCount() {
        int count = 0;
        for (Node child : getChildren()) {
            count += child.getQuarterTurnCount();
        }
        return count;
    }

    /**
     * The resolved enumeration.
     */
    private static class ResolvedIterator
            implements Iterator<Node> {

        /**
         * The root of the enumeration.
         */
        protected Node root;
        /**
         * Enumeration of the direct children of this node.
         */
        protected Iterator<Node> children;
        /**
         * Subtree at the current child.
         */
        protected Iterator<Node> subtree;
        /**
         * True when enumeration has to be inverse.
         */
        boolean inverse;

        public ResolvedIterator(Node rootNode, boolean inverse) {
            root = rootNode;
            this.inverse = inverse;
            children = (inverse) ? root.reversedChildIterator() : root.childIterator();
            subtree = new SingletonIterator<Node>(root);
        }

        @Override
        public boolean hasNext() {
            return subtree.hasNext() || children.hasNext();
        }

        @Override
        public Node next() {
            Node retval;

            if (subtree.hasNext()) {
                retval = subtree.next();
            } else if (children.hasNext()) {
                subtree = children.next().resolvedIterator(inverse);
                retval = subtree.next();
            } else {
                throw new NoSuchElementException();
            }
            return retval;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException("Not supported yet.");
        }
    }

    /**
     * Writes the token(s) represented by the subtree starting at this node. The
     * syntax and the string representations of the tokens are provided by the
     * parser.
     *
     * @param w This is where the tokens are written to.
     * @param n The notation which provides the tokens.
     * @param macroMap Local macros which are preserved by the translation.
     */
    public void writeTokens(PrintWriter w, Notation n, Map<String, MacroNode> macroMap)
            throws IOException {
        // FIXME - Implement macro coercion
        String macroName = null; // n.getEquivalentMacro(cube, macroMap);
        if (macroName != null) {
            w.write(macroName);
        } else {
            Iterator<Node> enumer = getChildren().iterator();
            while (enumer.hasNext()) {
                enumer.next().writeTokens(w, n, macroMap);
                if (enumer.hasNext()) {
                    try {
                        n.writeToken(w, Symbol.DELIMITER);
                    } catch (IOException e) {
                        // ignore no token for delimiter
                    }
                    w.write(' ');
                }
            }
        }
    }

    /**
     * Returns a deep clone of the subtree starting at this node.
     */
    public Node cloneSubtree() {
        Node that = clone();
        for (Node child : getChildren()) {
            that.add(child.cloneSubtree());
        }
        return that;
    }

    public List<Node> toResolvedList() {
        if (children == null) {
            return Collections.emptyList();
        } else {
            ListOfLists<Node> list = new ListOfLists<Node>();
            for (int i = 0; i < getChildCount(); i++) {
                list.addList(getChildAt(i).toResolvedList());
            }
            return list;
        }
    }

}
