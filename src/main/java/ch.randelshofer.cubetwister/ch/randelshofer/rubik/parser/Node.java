/* @(#)Node.java
 * Copyright (c) 2004 Werner Randelshofer, Switzerland. MIT License.
 */
package ch.randelshofer.rubik.parser;

import ch.randelshofer.gui.tree.TreeNodeImpl;
import ch.randelshofer.rubik.Cube;
import ch.randelshofer.rubik.notation.Notation;
import ch.randelshofer.rubik.notation.Symbol;
import ch.randelshofer.util.ReverseListIterator;

import javax.swing.tree.TreeNode;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;

/**
 * Abstract superclass for a Node in the parse tree generated by the Parser.
 *
 * @author Werner Randelshofer
 * @version $Id$
 * <br>3.1 2009-01-22 Fixed reflect() method.
 * <br>3.0 2007-11-15 Upgraded to Java 1.4.
 * <br>2.1 2007-11-04 Implemented method transformOrientation.
 * <br>2.0 2005-01-31 Reworked.
 * <br>1.0 31 January 2005 Created.
 */
public abstract class Node extends TreeNodeImpl<Node> {
    private static final long serialVersionUID = 1L;

    /**
     * The start position of the first token in the source code, that is part of
     * this script.
     */
    protected int startpos;
    /**
     * The end position of the last token in the source code, that is part of
     * this script.
     */
    protected int endpos;
    /**
     * The Symbol that this node represents.
     */
    protected Symbol symbol;

    public Node(Symbol symbol) {
        this.symbol = symbol;
    }


    /**
     * Creates a node which represents a symbol at the indicated position in the
     * source code.
     *  @param startpos The start position of the symbol.
     * @param endpos   The end position of the symbol.
     */
    public Node(Symbol symbol, int startpos, int endpos) {
        this.symbol = symbol;
        this.startpos = startpos;
        this.endpos = endpos;
    }

    public void addAll(List<Node> children) {
        for (Node n:children) add(n);
    }

    /**
     * Returns the start position of the symbol in the source code.
     */
    public int getStartPosition() {
        return startpos;
    }

    /**
     * Sets the start position of the symbol in the source code.
     */
    public void setStartPosition(int p) {
        startpos = p;
    }

    /**
     * Returns the end position of the symbol in the source code.
     */
    public int getEndPosition() {
        return endpos;
    }

    /**
     * Sets the end position of the symbol in the source code.
     */
    public void setEndPosition(int p) {
        endpos = p;
    }

    /**
     * Overwrite start and end positions of this node and the subtree starting
     * at this node.
     */
    public void overwritePositions(int sp, int ep) {
        startpos = sp;
        endpos = ep;
        if (children != null) {
            for (Node child : getChildren()) {
                child.overwritePositions(sp, ep);
            }
        }
    }

    /**
     * Applies the symbol represented by this node to the cube.
     *
     * @param cube    A cube to be transformed by this symbol.
     * @param inverse If true, the transform will be done in inverse order.
     */
    public void applyTo(Cube cube, boolean inverse) {
        for (Iterator<Node> i = (inverse) ? reversedChildIterator() : childIterator(); i.hasNext(); ) {
            Node child = i.next();
            child.applyTo(cube, inverse);
        }
    }

    /**
     * Returns the ScriptParser symbol that represents this node.
     */
    public Symbol getSymbol() {
        return symbol;
    }

    /**
     * Dumps the subtree starting at this Node node. Use for debugging only.
     *
     * @param depth The number of spaces used for indenting.
     */
    public void dumpTree(int depth) {
        StringBuilder buf = new StringBuilder(depth);
        for (int i = 0; i < depth; i++) {
            buf.append('.');
        }
        buf.append(toString());
        System.out.println(buf.toString());
        depth++;
        for (Node n : getChildren()) {
            n.dumpTree(depth);
        }
    }

    @Override
    public String toString() {
        StringBuilder b = new StringBuilder();
        b.append(getStartPosition());
        b.append("..");
        b.append(getEndPosition());
        b.append(getClass().getSimpleName());
        b.append("{");
        for (Node n : getChildren()) {
            b.append(' ');
            b.append(n.toString());
        }
        b.append(' ');
        b.append("}");
        return b.toString();
    }

    /**
     * Returns a string representation of this node using the specified
     * notation.
     */
    public final String toString(Notation notation) throws IOException {
        return toString(notation, null);
    }

    /**
     * Returns a string representation of this node using the specified notation
     * and the specified local macros.
     */
    public final String toString(Notation notation, List<MacroNode> localMacros) throws IOException {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        HashMap<String, MacroNode> macroMap = new HashMap<String, MacroNode>();
        if (localMacros != null) {
            for (MacroNode mn : localMacros) {
                macroMap.put(mn.getIdentifier(), mn);
            }
        }

        writeTokens(pw, notation, macroMap);
        pw.close();
        return sw.toString();
    }

    /**
     * Transformes the subtree starting at this node by the given move. Does
     * nothing if the transformation can not be done.
     */
    public void transform(int axis, int layerMask, int angle) {
        for (Node elem : getChildren()) {
            elem.transform(axis, layerMask, angle);
        }
    }

    public void transform(MoveNode move, boolean inverse) {
        transform(move.getAxis(), move.getLayerMask(), (inverse) ? -move.getAngle() : move.getAngle());
    }


    /**
     * Inverses the subtree starting at this node.
     */
    @SuppressWarnings("unchecked")
    public void inverse() {
        if (children != null) {
            Iterator<Node> enumer = reversedChildIterator();
            children = new Vector<TreeNode>();
            while (enumer.hasNext()) {
                Node elem = enumer.next();
                elem.inverse();
                children.addElement(elem);
            }
        }
    }

    /**
     * Reflects the subtree starting at this node.
     */
    public void reflect() {
        if (children != null) {
            for (Node elem : getChildren()) {
                elem.reflect();
            }
        }
    }

    /**
     * Enumerates a resolved version of the subtree starting at this node. All
     * elements of the enumeration except of MoveNode's and PermutationNode's
     * may be safely ignored.
     *
     * @param inverse Set to true if you wish to get an inverted enumeration.
     */
    public Iterator<Node> resolvedIterator(boolean inverse) {
        return new ResolvedIterator(this, inverse);
    }

    public Iterable<Node> resolvedIterable(final boolean inverse) {
        return () -> resolvedIterator(inverse);
    }

    public List<Node> toResolvedList(boolean inverse) {
        List<Node> list = new ArrayList<>();
        resolvedIterator(inverse).forEachRemaining(list::add);
        return list;
    }

    @SuppressWarnings("unchecked")
    public Iterator<Node> childIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return children == null ? empty : (Iterator<Node>) (Iterator<?>) children.iterator();
    }

    /**
     * Enumerates the direct children of this node in reverse order.
     */
    @SuppressWarnings("unchecked")
    public Iterator<Node> reversedChildIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return (children == null) ? empty : new ReverseListIterator<Node>((List<Node>) (List<?>) children);
    }

    /**
     * The resolved enumeration.
     */
    private static class ResolvedIterator
            implements Iterator<Node> {

        /**
         * Enumeration of the direct children of this node.
         */
        private Iterator<Node> children;
        /**
         * Subtree at the current child.
         */
        private Iterator<Node> current;
        /**
         * True when enumeration has to be inverse.
         */
        private final boolean inverse;

        public ResolvedIterator(Node root, boolean inverse) {
            this.inverse = inverse;
            children = (inverse) ? root.reversedChildIterator() : root.childIterator();
            current = Collections.emptyIterator();
        }

        private boolean move() {
            if (!current.hasNext()) {
                while (children.hasNext()) {
                    current = children.next().resolvedIterator(inverse);
                    if (current.hasNext()) {
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public boolean hasNext() {
            return current.hasNext() || move();
        }

        @Override
        public Node next() {
            move();
            return current.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * Writes the token(s) represented by the subtree starting at this node. The
     * syntax and the string representations of the tokens are provided by the
     * parser.
     *
     * @param w        This is where the tokens are written to.
     * @param n        The notation which provides the tokens.
     * @param macroMap Local macros which are preserved by the translation.
     */
    public void writeTokens(PrintWriter w, Notation n, Map<String, MacroNode> macroMap)
            throws IOException {
        // FIXME - Implement macro coercion
        String macroName = null; // n.getEquivalentMacro(cube, macroMap);
        if (macroName != null) {
            w.write(macroName);
        } else {
            Iterator<Node> enumer = getChildren().iterator();
            while (enumer.hasNext()) {
                enumer.next().writeTokens(w, n, macroMap);
                if (enumer.hasNext()) {
                    try {
                        n.writeToken(w, Symbol.DELIMITER);
                    } catch (IOException e) {
                        // ignore no token for delimiter
                    }
                    w.write(' ');
                }
            }
        }
    }

    /**
     * Returns a deep clone of the subtree starting at this node.
     */
    public Node cloneSubtree() {
        Node that = clone();
        for (Node child : getChildren()) {
            that.add(child.cloneSubtree());
        }
        return that;
    }
}
